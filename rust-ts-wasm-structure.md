# Rust-TypeScript-WASM Architecture Guide

## Overview

This project implements high-performance statistical computations using a Rust â†’ WASM â†’ TypeScript architecture. Statistical functions are implemented in Rust, compiled to WebAssembly, and exposed through TypeScript APIs with comprehensive R validation.

## Architecture Layers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    TypeScript API Layer                     â”‚
â”‚  /src/dataframe/ts/stats/statistical-tests/                â”‚
â”‚  â€¢ User-facing functions with clear interfaces             â”‚
â”‚  â€¢ Input validation and error handling                     â”‚
â”‚  â€¢ Documentation and JSDoc comments                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     WASM Bridge Layer                      â”‚
â”‚  /src/dataframe/ts/wasm/                                   â”‚
â”‚  â€¢ WASM function imports and initialization               â”‚
â”‚  â€¢ Type conversions between TS and WASM                   â”‚
â”‚  â€¢ Memory management helpers                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Generated WASM Bindings                     â”‚
â”‚  /src/dataframe/lib/                                       â”‚
â”‚  â€¢ Auto-generated by wasm-bindgen                         â”‚
â”‚  â€¢ tidy_ts_dataframe.js/d.ts/wasm                        â”‚
â”‚  â€¢ Internal JS binding code                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Rust Implementation                     â”‚
â”‚  /src/dataframe/rust/stats/statistical_tests/             â”‚
â”‚  â€¢ Core statistical algorithms                            â”‚
â”‚  â€¢ WASM export functions                                  â”‚
â”‚  â€¢ High-performance computations                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Directory Structure

### Rust Layer (`/src/dataframe/rust/`)

```
src/dataframe/rust/
â”œâ”€â”€ lib.rs                          # Main Rust library entry point
â”œâ”€â”€ stats/
â”‚   â”œâ”€â”€ mod.rs                      # Stats module organization
â”‚   â”œâ”€â”€ core/                       # Core types and utilities
â”‚   â”‚   â”œâ”€â”€ mod.rs
â”‚   â”‚   â””â”€â”€ types.rs               # TestResult, TestType definitions
â”‚   â”œâ”€â”€ statistical_tests/          # All statistical test implementations
â”‚   â”‚   â”œâ”€â”€ mod.rs                 # Module exports
â”‚   â”‚   â”œâ”€â”€ [test_name]/           # Each test in its own module
â”‚   â”‚   â”‚   â”œâ”€â”€ mod.rs             # Module re-exports
â”‚   â”‚   â”‚   â”œâ”€â”€ [algorithm].rs     # Core implementation
â”‚   â”‚   â”‚   â””â”€â”€ wasm.rs           # WASM bindings for this test
â”‚   â”‚   â””â”€â”€ post_hoc/             # Example: Post-hoc tests
â”‚   â”‚       â”œâ”€â”€ mod.rs            # Re-exports: tukey_hsd, games_howell, etc.
â”‚   â”‚       â”œâ”€â”€ types.rs          # Shared types: PairwiseComparison, PostHocResult
â”‚   â”‚       â”œâ”€â”€ tukey_hsd.rs      # Tukey HSD implementation
â”‚   â”‚       â”œâ”€â”€ games_howell.rs   # Games-Howell implementation
â”‚   â”‚       â”œâ”€â”€ dunn.rs           # Dunn's test implementation
â”‚   â”‚       â””â”€â”€ wasm.rs           # WASM exports: tukey_hsd_wasm(), etc.
â”‚   â””â”€â”€ distributions/             # Probability distributions
â””â”€â”€ Cargo.toml                     # Rust dependencies and WASM config
```

### TypeScript Layer (`/src/dataframe/ts/`)

```
src/dataframe/ts/
â”œâ”€â”€ stats/
â”‚   â””â”€â”€ statistical-tests/
â”‚       â”œâ”€â”€ index.ts               # Main exports - all statistical tests
â”‚       â”œâ”€â”€ types.ts               # TypeScript type definitions
â”‚       â”œâ”€â”€ [test-name].ts         # Individual test implementations
â”‚       â””â”€â”€ post-hoc.ts           # Example: Post-hoc test functions
â””â”€â”€ wasm/
    â”œâ”€â”€ wasm-loader.ts             # Main WASM exports
    â”œâ”€â”€ wasm-init.ts               # WASM initialization utilities
    â”œâ”€â”€ statistical-tests.ts      # WASM statistical test bindings
    â””â”€â”€ [feature]-functions.ts    # Other WASM function categories
```

### Generated WASM Layer (`/src/dataframe/lib/`)

```
src/dataframe/lib/                 # ğŸš¨ AUTO-GENERATED - DO NOT EDIT
â”œâ”€â”€ tidy_ts_dataframe.wasm         # Compiled WebAssembly binary
â”œâ”€â”€ tidy_ts_dataframe.js           # Main WASM loader
â”œâ”€â”€ tidy_ts_dataframe.internal.js # Internal WASM bindings
â””â”€â”€ tidy_ts_dataframe.d.ts         # TypeScript definitions for WASM
```

### Validation Layer (`/src/dataframe/rust/stats/statistical_tests/`)

```
statistical_tests/
â”œâ”€â”€ run_all_tests.ts              # Comprehensive test runner
â”œâ”€â”€ test-helpers.ts               # R comparison utilities
â”œâ”€â”€ test-helpers.R                # R helper functions
â”œâ”€â”€ [test_name].test.ts           # TypeScript test files
â”œâ”€â”€ [test_name].test.R            # R comparison implementations
â””â”€â”€ post_hoc_tests.test.ts        # Example: Post-hoc validation
```

## Implementation Pattern

### 1. Rust Implementation

**Core Algorithm** (`/src/dataframe/rust/stats/statistical_tests/post_hoc/tukey_hsd.rs`):
```rust
use super::types::{PairwiseComparison, PostHocResult};

pub fn tukey_hsd<T, I>(groups: &[I], alpha: f64) -> (PostHocResult, Vec<PairwiseComparison>)
where
    T: Into<f64> + Copy,
    I: AsRef<[T]>,
{
    // Core statistical algorithm implementation
    // Returns structured results
}
```

**WASM Bindings** (`/src/dataframe/rust/stats/statistical_tests/post_hoc/wasm.rs`):
```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn tukey_hsd_wasm(data: &[f64], group_sizes: &[usize], alpha: f64) -> String {
    // Convert flat data to groups
    let groups = reconstruct_groups(data, group_sizes);
    
    // Call core algorithm
    let (result, comparisons) = tukey_hsd(&groups, alpha);
    
    // Serialize to JSON (manual to avoid serde_json dependency)
    format_as_json(&result, &comparisons)
}
```

### 2. TypeScript Interface

**High-level API** (`/src/dataframe/ts/stats/statistical-tests/post-hoc.ts`):
```typescript
import { tukey_hsd_wasm } from "../../wasm/wasm-loader.ts";

export function tukeyHSD(groups: number[][], alpha = 0.05): PostHocTestResult {
    // Input validation
    if (groups.length < 2) {
        throw new Error("Tukey HSD requires at least 2 groups");
    }
    
    // Convert groups to flat data for WASM
    const flatData = groups.flat();
    const groupSizes = groups.map(g => g.length);
    
    // Call WASM function
    const resultJson = tukey_hsd_wasm(
        new Float64Array(flatData),
        new Uint32Array(groupSizes),
        alpha
    );
    
    // Parse and return structured result
    const [result, comparisons] = JSON.parse(resultJson);
    return { ...result, comparisons };
}
```

**WASM Bridge** (`/src/dataframe/ts/wasm/statistical-tests.ts`):
```typescript
import * as wasmInternal from "../../lib/tidy_ts_dataframe.internal.js";
import { initWasm } from "./wasm-init.ts";

export function tukey_hsd_wasm(
    data: Float64Array,
    group_sizes: Uint32Array,
    alpha: number
): string {
    initWasm();  // Ensure WASM is loaded
    return wasmInternal.tukey_hsd_wasm(data, group_sizes, alpha);
}
```

## Build Process

### WASM Compilation

The build process uses `@deno/wasmbuild` to compile Rust to WASM:

```bash
# Main build command
deno task wasmbuild

# This runs:
# 1. cargo build --target wasm32-unknown-unknown --features wasm --release
# 2. wasm-bindgen to generate JS bindings
# 3. wasm-opt to optimize the binary
```

**Configuration** (`Cargo.toml`):
```toml
[package]
name = "tidy-ts-dataframe"

[lib]
crate-type = ["cdylib"]

[features]
wasm = ["wasm-bindgen"]

[dependencies]
wasm-bindgen = { version = "0.2", optional = true }
statrs = "0.16"  # Statistical distributions

[dependencies.web-sys]
version = "0.3"
features = ["console"]
optional = true
```

**Build Script** (`deno.json`):
```json
{
  "tasks": {
    "wasmbuild": "deno run -A jsr:@deno/wasmbuild@0.19.2 --features wasm --out src/dataframe/lib"
  }
}
```

### Type Generation

WASM-bindgen automatically generates:
- `tidy_ts_dataframe.d.ts` - TypeScript definitions
- `tidy_ts_dataframe.js` - WASM loader
- `tidy_ts_dataframe.internal.js` - Internal bindings

## Data Flow

### Input Processing
```
TypeScript Array â†’ Float64Array â†’ Rust Vec<f64> â†’ Algorithm
```

### Output Processing
```
Rust Struct â†’ Manual JSON â†’ TypeScript String â†’ JSON.parse() â†’ Typed Object
```

### Memory Management
- **WASM Memory**: Managed by wasm-bindgen
- **Large Arrays**: Passed by reference to avoid copying
- **Results**: Small JSON strings copied back to JS

## Testing Architecture

### Validation Strategy
1. **Unit Tests**: Rust algorithm correctness
2. **Integration Tests**: WASM binding functionality  
3. **Comparison Tests**: Results vs. R statistical packages
4. **Performance Tests**: Benchmarking and scaling

### R Comparison Framework

**Test Structure**:
```typescript
// TypeScript test runner
const testCases = [
    {
        testName: "Tukey HSD",
        func: "post.hoc.tukey",         // R function name
        distribution: "post_hoc_tests", // R test file
        args: [JSON.stringify(groups), alpha.toString()]
    }
];

const results = await runComparison(testCases);
```

**R Implementation** (`post_hoc_tests.test.R`):
```r
# R validation functions
tukey_hsd_test <- function(groups_json, alpha) {
    # Parse data, run R implementation
    # Return standardized result format
    list(
        test_statistic = result$statistic,
        p_value = result$p.value,
        method = "Tukey HSD"
    )
}
```

## Performance Characteristics

### Benchmarks (4 groups, 5 observations each)
- **Tukey HSD**: ~0.030ms per call
- **Games-Howell**: ~0.030ms per call  
- **Dunn's test**: ~0.024ms per call

### Scaling (Linear with number of comparisons)
- **3 groups (3 comparisons)**: ~0.026ms
- **6 groups (15 comparisons)**: ~0.084ms

### Memory Usage
- **Minimal heap allocation** in Rust
- **Zero-copy** for large datasets where possible
- **Automatic cleanup** via wasm-bindgen

## Adding New Statistical Tests

### 1. Implement in Rust

Create `/src/dataframe/rust/stats/statistical_tests/new_test/`:
```rust
// mod.rs
pub mod implementation;
pub mod wasm;
pub use implementation::*;

// implementation.rs  
pub fn new_statistical_test(data: &[f64]) -> TestResult {
    // Algorithm implementation
}

// wasm.rs
#[wasm_bindgen]
pub fn new_test_wasm(data: &[f64]) -> String {
    let result = new_statistical_test(data);
    serde_json::to_string(&result).unwrap()
}
```

### 2. Add WASM Bridge

In `/src/dataframe/ts/wasm/statistical-tests.ts`:
```typescript
export function new_test_wasm(data: Float64Array): string {
    initWasm();
    return wasmInternal.new_test_wasm(data);
}
```

### 3. Create TypeScript API

In `/src/dataframe/ts/stats/statistical-tests/new-test.ts`:
```typescript
export function newStatisticalTest(data: number[]): TestResult {
    const result = new_test_wasm(new Float64Array(data));
    return JSON.parse(result);
}
```

### 4. Add to Exports

Update `/src/dataframe/ts/stats/statistical-tests/index.ts`:
```typescript
export * from "./new-test.ts";
```

### 5. Build and Test

```bash
# Rebuild WASM
deno task wasmbuild

# Add R comparison test
# Create new_test.test.R and new_test.test.ts

# Run comprehensive tests
deno run --allow-read --allow-run run_all_tests.ts
```

## Common Patterns

### Error Handling
```rust
// Rust: Return error in result structure
if data.is_empty() {
    return TestResult {
        error_message: Some("Data cannot be empty".to_string()),
        ..Default::default()
    };
}
```

```typescript
// TypeScript: Validate and throw
if (data.length === 0) {
    throw new Error("Data cannot be empty");
}
```

### Type Safety
- **Rust**: Generic functions with trait bounds
- **WASM**: Convert to basic types (f64, String)
- **TypeScript**: Strongly typed interfaces

### Performance Optimization
- **Pre-allocate vectors** in Rust when size is known
- **Use iterators** instead of indexing
- **Minimize JSON serialization** overhead
- **Batch WASM calls** when possible

## Troubleshooting

### Build Issues
```bash
# Clean rebuild
rm -rf src/dataframe/lib/*
deno task wasmbuild

# Check Rust compilation
cd src/dataframe/rust
cargo check --target wasm32-unknown-unknown --features wasm
```

### WASM Loading Issues
```typescript
// Ensure WASM is initialized
import { initWasm } from "./wasm-init.ts";
initWasm();  // Call before any WASM functions
```

### Type Errors
```bash
# Regenerate TypeScript definitions
deno task wasmbuild

# Check generated types
cat src/dataframe/lib/tidy_ts_dataframe.d.ts
```

This architecture provides excellent performance (microsecond-level execution), type safety, and maintainability while enabling comprehensive validation against established R implementations.